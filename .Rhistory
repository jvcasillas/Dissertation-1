knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# Get full mod and make it pretty for the table
pretty_fixed_effects_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3 %>%
tidy_lme4() %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p)
# Include gammas (Gij) after each parameter name
subs <- c(paste0(0:3, 0), paste0(0:3, 1),
paste0(0:3, 2), paste0(0:3, 3),
paste0(0:3, 4), paste0(0:3, 5),
paste0(0:3, 6))
var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", subs, "~"))
pretty_fixed_effects_rhythm$Parameter %<>% paste(., var_labels)
pretty_fixed_effects_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
ranef_table_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3 %>%
tidy_ranef_summary %>%
# Format the numbers
mutate_each(funs(format_fixef_num), vcov, sdcor) %>%
mutate_each(funs(format_cor), -var1, -grp, -vcov, -sdcor) %>%
sort_ranef_grps %>%
# Format variable names and group names
mutate(var1 = fix_param_names(var1) %>% blank_nas,
grp =  blank_same_as_last(grp) %>% fix_param_names) %>%
rename(Group = grp, Parameter = var1, Variance = vcov, SD = sdcor)
# Correlation columns need names with characters so that pandoc can align them
names(ranef_table_rhythm)[5:9] <-
c("Correlations", "&nbsp;", " &nbsp;", "  &nbsp;", "  &nbsp;")
ranef_table_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("llrrrrrr"))
# make table for printing
pairwise_comp_en_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_aes %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ies") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_en_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
pairwise_comp_en_rhythm <- tibble::column_to_rownames(pairwise_comp_en_rhythm, 'subscript')
pairwise_comp_en_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_en_rhythm <- function(row_name) report_fixef_row(pairwise_comp_en_rhythm, row_name)
# Make table for appendix
pretty_pairwise_table_en_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_aes %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IE") == TRUE)
pretty_pairwise_table_en_rhythm$Parameter %<>% str_replace("Group AA", "AE - IE")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:4, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_en_rhythm$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_en_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_ma_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ims") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_ma_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
pairwise_comp_ma_rhythm <- tibble::column_to_rownames(pairwise_comp_ma_rhythm, 'subscript')
pairwise_comp_ma_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_ma_rhythm <- function(row_name) report_fixef_row(pairwise_comp_ma_rhythm, row_name)
# Make table for appendix
pretty_pairwise_table_ma_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_ams %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IM") == TRUE)
pretty_pairwise_table_ma_rhythm$Parameter %<>% str_replace("Group AM", "AM - IM")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:4, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_ma_rhythm$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_ma_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_adv_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_aes %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ams") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_adv_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
pairwise_comp_adv_rhythm <- tibble::column_to_rownames(pairwise_comp_adv_rhythm, 'subscript')
pairwise_comp_adv_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_adv_rhythm <- function(row_name) report_fixef_row(pairwise_comp_adv_rhythm, row_name)
# Make table for appendix
pretty_pairwise_table_adv_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_aes %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "AM") == TRUE)
pretty_pairwise_table_adv_rhythm$Parameter %<>% str_replace("Group AE", "AE - AM")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:4, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_adv_rhythm$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_adv_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_int_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_ies %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ims") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_int_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
pairwise_comp_int_rhythm <- tibble::column_to_rownames(pairwise_comp_int_rhythm, 'subscript')
pairwise_comp_int_rhythm$subscript <- c(paste0(0:4, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_int_rhythm <- function(row_name) report_fixef_row(pairwise_comp_int_rhythm, row_name)
# Make table for appendix
pretty_pairwise_table_int_rhythm <- rhythm_mods$gca_full_mod_rhythm_int_3_ies %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IM") == TRUE)
pretty_pairwise_table_int_rhythm$Parameter %<>% str_replace("Group IE", "IE - IM")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:4, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_int_rhythm$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_int_rhythm %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
auditory <- read_csv("./data/clean/auditory_scores.csv")
music50 <- merge(x = stress50, y = auditory, by = "participant", all.x=TRUE)
music50 <- na.omit(music50)
stress_gc_subset <- music50 %>%
filter(., time_zero >= -4 & time_zero <= 12) %>%
mutate(., group = fct_relevel(group, "mon", "aes", "ams", "ies", "ims"),
stress_sum = if_else(cond == "1", 1, -1)) %>%           # 1 = present, 2 = preterit
poly_add_columns(., time_zero, degree = 3, prefix = "ot")
gca_mod_aes_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa', optCtrl = list(maxfun = 3e5)),
REML = F,
data = filter(stress_gc_subset, group == "aes")) # singular
gca_mod_aes_cond_2 <- update(gca_mod_aes_base, . ~ . + ot2:stress_sum) # singular
gca_mod_aes_rhythm_1 <- update(gca_mod_aes_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_rhythm_0 <- update(gca_mod_aes_cond_2,   . ~ . + rhythm_dev) # singular
summary(gca_mod_aes_cond_2)
# add pitch synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_pitch_0 <- update(gca_mod_aes_cond_2,    . ~ . + pitch_dev) # singular
gca_mod_aes_pitch_1 <- update(gca_mod_aes_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_aes_pitch_2 <- update(gca_mod_aes_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_aes_pitch_3 <- update(gca_mod_aes_pitch_2, . ~ . + ot3:pitch_dev) # singular
aes_pitch_anova <-
anova(gca_mod_aes_cond_2, gca_mod_aes_pitch_0, gca_mod_aes_pitch_1,
gca_mod_aes_pitch_2, gca_mod_aes_pitch_3)
aes_pitch_anova
gca_mod_ies_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ies")) # singular
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_rhythm_0 <- update(gca_mod_ies_base,     . ~ . + rhythm_dev) # singular
gca_mod_ies_rhythm_2 <- update(gca_mod_ies_base, . ~ . + ot2:rhythm_dev) # singular
summary(gca_mod_ies_rhythm_2)
# add pitch anticipation effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_pitch_0 <- update(gca_mod_ies_base,    . ~ . + pitch_dev) # singular
gca_mod_ies_pitch_1 <- update(gca_mod_ies_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_ies_pitch_2 <- update(gca_mod_ies_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_ies_pitch_3 <- update(gca_mod_ies_pitch_2, . ~ . + ot3:pitch_dev) # singular
ies_pitch_anova <-
anova(gca_mod_ies_base, gca_mod_ies_pitch_0, gca_mod_ies_pitch_1,
gca_mod_ies_pitch_2, gca_mod_ies_pitch_3)
ies_pitch_anova
# Get path to saved models
gca_mods_path  <- here("mods", "music", "gca")
# Load models as lists
load(paste0(gca_mods_path, "/ind_mods.Rdata"))
# load(paste0(gca_mods_path, "/nested_model_comparisons.Rdata"))
# load(paste0(gca_mods_path, "/model_preds.Rdata"))
#
# # Store objects in global env
list2env(ind_mods, globalenv())
gca_mod_mon_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 3e5)),    # 2e4
REML = F, #na.action = na.exclude,
data = filter(stress_gc_subset, group == 'mon')) # singular
# add condition (paroxytone, oxytone) effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_mon_cond_0 <- update(gca_mod_mon_base,   . ~ . + stress_sum) # singular
gca_mod_mon_cond_1 <- update(gca_mod_mon_cond_0, . ~ . + ot1:stress_sum) # singular
gca_mod_mon_cond_2 <- update(gca_mod_mon_cond_1, . ~ . + ot2:stress_sum) # singular
gca_mod_mon_cond_2 <- update(gca_mod_mon_cond_1, . ~ . + ot2:stress_sum) # singular
gca_mod_mon_cond_3 <- update(gca_mod_mon_cond_2, . ~ . + ot3:stress_sum) # singular
mon_cond_anova <-
anova(gca_mod_mon_base, gca_mod_mon_cond_0, gca_mod_mon_cond_1,
gca_mod_mon_cond_2, gca_mod_mon_cond_3) #
mon_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_mon_rhythm_0 <- update(gca_mod_mon_base,     . ~ . + rhythm_dev) # singular
gca_mod_mon_rhythm_1 <- update(gca_mod_mon_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_mon_rhythm_2 <- update(gca_mod_mon_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
gca_mod_mon_rhythm_3 <- update(gca_mod_mon_rhythm_2, . ~ . + ot3:rhythm_dev) # singular
mon_rhythm_anova <-
anova(gca_mod_mon_base, gca_mod_mon_rhythm_0, gca_mod_mon_rhythm_1,
gca_mod_mon_rhythm_2, gca_mod_mon_rhythm_3)
mon_rhythm_anova
# add pitch anticipation effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_mon_pitch_0 <- update(gca_mod_mon_base,    . ~ . + pitch_dev) # singular
gca_mod_mon_pitch_1 <- update(gca_mod_mon_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_mon_pitch_2 <- update(gca_mod_mon_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_mon_pitch_3 <- update(gca_mod_mon_pitch_2, . ~ . + ot3:pitch_dev) # singular
mon_pitch_anova <-
anova(gca_mod_mon_base, gca_mod_mon_pitch_0, gca_mod_mon_pitch_1,
gca_mod_mon_pitch_2, gca_mod_mon_pitch_3)
mon_pitch_anova
gca_mod_aes_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa', optCtrl = list(maxfun = 3e5)),
REML = F,
data = filter(stress_gc_subset, group == "aes")) # singular
# add condition (paroxytone, oxytone) effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_cond_0 <- update(gca_mod_aes_base,   . ~ . + stress_sum) # singular
gca_mod_aes_cond_1 <- update(gca_mod_aes_cond_0, . ~ . + ot1:stress_sum) # singular
gca_mod_aes_cond_2 <- update(gca_mod_aes_cond_1, . ~ . + ot2:stress_sum) # singular
gca_mod_aes_cond_3 <- update(gca_mod_aes_cond_2, . ~ . + ot3:stress_sum) # singular
aes_cond_anova <-
anova(gca_mod_aes_base, gca_mod_aes_cond_0, gca_mod_aes_cond_1,
gca_mod_aes_cond_2, gca_mod_aes_cond_3) #
aes_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_rhythm_0 <- update(gca_mod_aes_cond_2,   . ~ . + rhythm_dev) # singular
gca_mod_aes_rhythm_1 <- update(gca_mod_aes_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_aes_rhythm_2 <- update(gca_mod_aes_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
gca_mod_aes_rhythm_3 <- update(gca_mod_aes_rhythm_2, . ~ . + ot3:rhythm_dev) # singular
aes_rhythm_anova <-
anova(gca_mod_aes_cond_2, gca_mod_aes_rhythm_0, gca_mod_aes_rhythm_1,
gca_mod_aes_rhythm_2, gca_mod_aes_rhythm_3)
aes_rhythm_anova
# add pitch synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_pitch_0 <- update(gca_mod_aes_cond_2,    . ~ . + pitch_dev) # singular
gca_mod_aes_pitch_1 <- update(gca_mod_aes_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_aes_pitch_2 <- update(gca_mod_aes_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_aes_pitch_3 <- update(gca_mod_aes_pitch_2, . ~ . + ot3:pitch_dev) # singular
aes_pitch_anova <-
anova(gca_mod_aes_cond_2, gca_mod_aes_pitch_0, gca_mod_aes_pitch_1,
gca_mod_aes_pitch_2, gca_mod_aes_pitch_3)
aes_pitch_anova
gca_mod_ies_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ies")) # singular
# add condition (paroxytone, oxytone) effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_cond_0 <- update(gca_mod_ies_base,     . ~ . + stress_sum) # singular
gca_mod_ies_cond_1 <- update(gca_mod_ies_cond_0,   . ~ . + ot1:stress_sum) # singular
gca_mod_ies_cond_2 <- update(gca_mod_ies_cond_1,   . ~ . + ot2:stress_sum) # singular
gca_mod_ies_cond_3 <- update(gca_mod_ies_cond_2,   . ~ . + ot3:stress_sum) # singular
ies_cond_anova <-
anova(gca_mod_ies_base, gca_mod_ies_cond_0, gca_mod_ies_cond_1,
gca_mod_ies_cond_2, gca_mod_ies_cond_3)
ies_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_rhythm_0 <- update(gca_mod_ies_base,     . ~ . + rhythm_dev) # singular
gca_mod_ies_rhythm_1 <- update(gca_mod_ies_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_ies_rhythm_2 <- update(gca_mod_ies_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
gca_mod_ies_rhythm_3 <- update(gca_mod_ies_rhythm_2, . ~ . + ot3:rhythm_dev) # singular
ies_rhythm_anova <-
anova(gca_mod_ies_base, gca_mod_ies_rhythm_0, gca_mod_ies_rhythm_1,
gca_mod_ies_rhythm_2, gca_mod_ies_rhythm_3)
ies_rhythm_anova
# add pitch anticipation effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_pitch_0 <- update(gca_mod_ies_base,    . ~ . + pitch_dev) # singular
gca_mod_ies_pitch_1 <- update(gca_mod_ies_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_ies_pitch_2 <- update(gca_mod_ies_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_ies_pitch_3 <- update(gca_mod_ies_pitch_2, . ~ . + ot3:pitch_dev) # singular
ies_pitch_anova <-
anova(gca_mod_ies_base, gca_mod_ies_pitch_0, gca_mod_ies_pitch_1,
gca_mod_ies_pitch_2, gca_mod_ies_pitch_3)
ies_cond_anova
ies_pitch_anova
gca_mod_ams_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ams"))
# add cond effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ams_cond_0 <- update(gca_mod_ams_base,     . ~ . + stress_sum)
gca_mod_ams_cond_1 <- update(gca_mod_ams_cond_0,   . ~ . + ot1:stress_sum)
gca_mod_ams_cond_2 <- update(gca_mod_ams_cond_1,   . ~ . + ot2:stress_sum) # singular
gca_mod_ams_cond_3 <- update(gca_mod_ams_cond_2,   . ~ . + ot3:stress_sum) # singular
ams_cond_anova <-
anova(gca_mod_ams_base, gca_mod_ams_cond_0, gca_mod_ams_cond_1,
gca_mod_ams_cond_2, gca_mod_ams_cond_3)
ies_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ams_rhythm_0 <- update(gca_mod_ams_base,   . ~ . + rhythm_dev) # singular
gca_mod_ams_rhythm_1 <- update(gca_mod_ams_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_ams_rhythm_2 <- update(gca_mod_ams_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
ams_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ams_rhythm_0 <- update(gca_mod_ams_cond_2,   . ~ . + rhythm_dev) # singular
gca_mod_ams_rhythm_1 <- update(gca_mod_ams_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_ams_rhythm_2 <- update(gca_mod_ams_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
gca_mod_ams_rhythm_3 <- update(gca_mod_ams_rhythm_2, . ~ . + ot3:rhythm_dev) # singular
ams_rhythm_anova <-
anova(gca_mod_ams_cond_2, gca_mod_ams_rhythm_0, gca_mod_ams_rhythm_1,
gca_mod_ams_rhythm_2, gca_mod_ams_rhythm_3)
ams_rhythm_anova
# add pitch anticipation effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ams_pitch_0 <- update(gca_mod_ams_cond_2,  . ~ . + pitch_dev) # singular
gca_mod_ams_pitch_1 <- update(gca_mod_ams_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_ams_pitch_2 <- update(gca_mod_ams_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_ams_pitch_3 <- update(gca_mod_ams_pitch_2, . ~ . + ot3:pitch_dev) # singular
ams_pitch_anova <-
anova(gca_mod_ams_cond_2, gca_mod_ams_pitch_0, gca_mod_ams_pitch_1,
gca_mod_ams_pitch_2, gca_mod_ams_pitch_3)
ams_pitch_anova
gca_mod_ims_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ims")) # singular
# add cond effect to imsercept, linear slope, quadratic, and cubic time terms
gca_mod_ims_cond_0 <- update(gca_mod_ims_base,     . ~ . + stress_sum) # singular
gca_mod_ims_cond_1 <- update(gca_mod_ims_cond_0,   . ~ . + ot1:stress_sum) # singular
gca_mod_ims_cond_2 <- update(gca_mod_ims_cond_1,   . ~ . + ot2:stress_sum) # singular
gca_mod_ims_cond_3 <- update(gca_mod_ims_cond_2,   . ~ . + ot3:stress_sum) # singular
ims_cond_anova <-
anova(gca_mod_ims_base, gca_mod_ims_cond_0, gca_mod_ims_cond_1, # none singular, and none significant
gca_mod_ims_cond_2, gca_mod_ims_cond_3)
ims_cond_anova
# add rhythm synchronization effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ims_rhythm_0 <- update(gca_mod_ims_base,   . ~ . + rhythm_dev) # singular
gca_mod_ims_rhythm_1 <- update(gca_mod_ims_rhythm_0, . ~ . + ot1:rhythm_dev) # singular
gca_mod_ims_rhythm_2 <- update(gca_mod_ims_rhythm_1, . ~ . + ot2:rhythm_dev) # singular
gca_mod_ims_rhythm_3 <- update(gca_mod_ims_rhythm_2, . ~ . + ot3:rhythm_dev) # singular
ims_rhythm_anova <-
anova(gca_mod_ims_wm_2, gca_mod_ims_rhythm_0, gca_mod_ims_rhythm_1,
gca_mod_ims_rhythm_2, gca_mod_ims_rhythm_3)
ims_rhythm_anova
ims_rhythm_anova <-
anova(gca_mod_ims_base, gca_mod_ims_rhythm_0, gca_mod_ims_rhythm_1,
gca_mod_ims_rhythm_2, gca_mod_ims_rhythm_3)
ims_rhythm_anova
# add pitch anticipation effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_ims_pitch_0 <- update(gca_mod_ims_base,    . ~ . + pitch_dev) # singular
gca_mod_ims_pitch_1 <- update(gca_mod_ims_pitch_0, . ~ . + ot1:pitch_dev) # singular
gca_mod_ims_pitch_2 <- update(gca_mod_ims_pitch_1, . ~ . + ot2:pitch_dev) # singular
gca_mod_ims_pitch_3 <- update(gca_mod_ims_pitch_2, . ~ . + ot3:pitch_dev) # singular
ims_pitch_anova <-
anova(gca_mod_ims_base, gca_mod_ims_pitch_0, gca_mod_ims_pitch_1,
gca_mod_ims_pitch_2, gca_mod_ims_pitch_3)
ims_pitch_anova
# Build model names programatically
mod_type <- "gca_mod_"
mod_spec <- c("_base", "_cond_0", "_cond_1", "_cond_2", "_cond_3",
"_rhythm_0", "_rhythm_1", "_rhythm_2", "_rhythm_3",
"_pitch_0", "_pitch_1", "_pitch_2", "_pitch_3")
# Store ind models in list
ind_mods <- mget(c(paste0(mod_type, "mon", mod_spec),
paste0(mod_type, "aes", mod_spec),
paste0(mod_type, "ies", mod_spec),
paste0(mod_type, "ams", mod_spec),
paste0(mod_type, "ims", mod_spec)
))
save(ind_mods,
file = here("mods", "music", "gca",
"ind_mods.Rdata"))
gca_mod_ams_rhythm_3
library("papaja")
library("officer")
library("flextable")
# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
#source(here::here("scripts", "02_load_data.R"))
source(here::here("scripts", "01_helpers.R"))
library("papaja")
library("officer")
library("flextable")
# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
#source(here::here("scripts", "02_load_data.R"))
source(here::here("scripts", "01_helpers.R"))
# Get path to saved models
gca_mods_path  <- here("mods", "vision", "gca")
# Load models as list and store full mod to global env
load(paste0(gca_mods_path, "/full_mods.Rdata"))
# make table for printing
pairwise_comp_en <- full_mods$gca_full_mod_int_1_aes %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ies") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_en$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
pairwise_comp_en <- tibble::column_to_rownames(pairwise_comp_en, 'subscript')
pairwise_comp_en$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_en <- function(row_name) report_fixef_row(pairwise_comp_en, row_name)
report_pairwise_en
# Make table for appendix
pretty_pairwise_table_en <- full_mods$gca_full_mod_int_1_aes %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IE") == TRUE)
pretty_pairwise_table_en$Parameter %<>% str_replace("Group AA", "AE - IE")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:2, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_en$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_en %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_ma <- full_mods$gca_full_mod_int_1_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ims") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_ma$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
pairwise_comp_ma <- tibble::column_to_rownames(pairwise_comp_ma, 'subscript')
pairwise_comp_ma$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_ma <- function(row_name) report_fixef_row(pairwise_comp_ma, row_name)
# Make table for appendix
pretty_pairwise_table_ma <- full_mods$gca_full_mod_int_1_ams %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IM") == TRUE)
pretty_pairwise_table_ma$Parameter %<>% str_replace("Group AM", "AM - IM")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:2, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_ma$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_ma %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_adv <- full_mods$gca_full_mod_int_1_aes %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ams") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_adv$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
pairwise_comp_adv <- tibble::column_to_rownames(pairwise_comp_adv, 'subscript')
pairwise_comp_adv$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_adv <- function(row_name) report_fixef_row(pairwise_comp_adv, row_name)
# Make table for appendix
pretty_pairwise_table_adv <- full_mods$gca_full_mod_int_1_aes %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "AM") == TRUE)
pretty_pairwise_table_adv$Parameter %<>% str_replace("Group AE", "AE - AM")
# Include gammas after each parameter name
pw_subs <- c(paste0(0:2, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_adv$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_adv %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
# make table for printing
pairwise_comp_int <- full_mods$gca_full_mod_int_1_ies %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ims") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp_int$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
pairwise_comp_int <- tibble::column_to_rownames(pairwise_comp_int, 'subscript')
pairwise_comp_int$subscript <- c(paste0(0:2, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise_int <- function(row_name) report_fixef_row(pairwise_comp_int, row_name)
# Make table for appendix
pretty_pairwise_table_int <- full_mods$gca_full_mod_int_1_ies %>%
tidy_lme4 %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p) %>%
filter(str_detect(Parameter, "IM") == TRUE)
# Include gammas after each parameter name
pw_subs <- c(paste0(0:2, 8), paste0(0:1, 9))
pw_var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", pw_subs, "~"))
pretty_pairwise_table_int$Parameter %<>% paste(., pw_var_labels)
pretty_pairwise_table_int %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
