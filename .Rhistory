update(mod_ot1, . ~ . -(1 + condition_sum + ot1 | participant) +
ot2 + (1 + condition_sum + ot1 + ot2 | participant))
mod_ot2 <-
update(mod_ot1, . ~ . -(1 + stress_sum + ot1 | participant) +
ot2 + (1 + stress_sum + ot1 + ot2 | participant))
mod_ot3 <-
update(mod_ot2, . ~ . -(1 + stress_sum + ot1 + ot2 | participant) +
ot3 + (1 + stress_sum + ot1 + ot2 + ot3 | participant))
mod_ot4 <- update(mod_ot3, . ~ . + (1 | target))
anova(mod_ot1, mod_ot2, mod_ot3, mod_ot4)
anova(mod_ot1, mod_ot2, mod_ot3, mod_ot4)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum + pitch_dev + rhythm_dev + WM_set + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 2e4)),
data = stress_gc_subset, REML = F)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum * pitch_dev * rhythm_dev * WM_set * (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 2e4)),
data = stress_gc_subset, REML = F)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum * (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 2e4)),
data = stress_gc_subset, REML = F)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum * (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), # ,optCtrl = list(maxfun = 2e4)
data = stress_gc_subset, REML = F)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum * (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 2e4)),
data = stress_gc_subset, REML = F)
# add group effect to intercept, linear slope, quadratic, and cubic time terms
gca_full_mod_group_0 <- update(gca_full_mod_base,    . ~ . + group)
gca_full_mod_group_1 <- update(gca_full_mod_group_0, . ~ . + ot1:group)
gca_full_mod_group_2 <- update(gca_full_mod_group_1, . ~ . + ot2:group)
gca_full_mod_group_3 <- update(gca_full_mod_group_2, . ~ . + ot3:group)
full_group_anova <-
anova(gca_full_mod_base, gca_full_mod_group_0, gca_full_mod_group_1,
gca_full_mod_group_2, gca_full_mod_group_3)
full_group_anova
full_group_anova <-
anova(gca_full_mod_base, gca_full_mod_group_0, gca_full_mod_group_1,
gca_full_mod_group_2, gca_full_mod_group_3)
full_group_anova
group_mods <- mget(c(paste0(mod_type, mod_spec)))
mod_type <- "gca_full_mod_"
mod_spec <- c("_base", "_group_0", "_group_1", "_group_2", "_group_3")
group_mods <- mget(c(paste0(mod_type, mod_spec)))
mod_type <- "gca_full_mod"
group_mods <- mget(c(paste0(mod_type, mod_spec)))
save(group_mods,
file = here("mods", "music", "gca",
"group_mods.Rdata"))
gca_full_mod_pitch <- update(gca_full_mod_group_2, . ~ . + pitch_dev)
gca_full_mod_pitch_1 <- update(gca_full_mod_group_pitch, . ~ . + o1:pitch_dev)
gca_full_mod_pitch_1 <- update(gca_full_mod_pitch, . ~ . + o1:pitch_dev)
gca_full_mod_pitch_1 <- update(gca_full_mod_pitch, . ~ . + ot1:pitch_dev)
gca_full_mod_pitch_2 <- update(gca_full_mod_pitch_1, . ~ . + ot2:pitch_dev)
gca_full_mod_pitch_3 <- update(gca_full_mod_pitch_2, . ~ . + ot3:pitch_dev)
full_pitch_anova <-
anova(gca_full_mod_group_2, gca_full_mod_pitch, gca_full_mod_pitch_1,
gca_full_mod_pitch_2, gca_full_mod_pitch_3)
# Base model
gca_full_mod_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + stress_sum * (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa',
optCtrl = list(maxfun = 2e4)),
data = stress_gc_subset, REML = F, na.action = na.exclude)
# add group effect to intercept, linear slope, quadratic, and cubic time terms
gca_full_mod_group_0 <- update(gca_full_mod_base,    . ~ . + group)
gca_full_mod_group_1 <- update(gca_full_mod_group_0, . ~ . + ot1:group)
gca_full_mod_group_2 <- update(gca_full_mod_group_1, . ~ . + ot2:group)
gca_full_mod_group_3 <- update(gca_full_mod_group_2, . ~ . + ot3:group)
library("papaja")
library("officer")
library("flextable")
library("papaja")
library("officer")
library("flextable")
install.packages("flextable")
library("flextable")
devtools::install_github("davidgohel/flextable")
install.packages("flextable")
library("flextable")
library("papaja")
library("officer")
library("flextable")
install.packages('systemfonts')
library("flextable")
install.packages("flextable", type = "binary")
library("flextable")
install.packages("gdtools", type = "source")
library("papaja")
library("officer")
library("flextable")
source(here::here("scripts", "02_load_data.R"))
library("papaja")
library("officer")
library("flextable")
source(here::here("scripts", "02_load_data.R"))
install.packages("TMB")
source(here::here("scripts", "02_load_data.R"))
source(here::here("scripts", "01_helpers.R"))
# Get path to saved models
gca_mods_path  <- here("mods", "stress", "gca")
# Load models as list and store full mod to global env
# load(paste0(gca_mods_path, "/ind_mods.Rdata"))
load(paste0(gca_mods_path, "/model_preds.Rdata"))
load(paste0(gca_mods_path, "/full_mods_int.Rdata"))
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present/n(oxytone)", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = group, color = group)) +
facet_grid(. ~ condition) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
geom_ribbon(alpha = 0.2, color = NA, show.legend = F) +
geom_line(size = 0.75) +
geom_point(aes(shape = group), color = "black", size = 1.3, show.legend = F) +
geom_point(aes(shape = group), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
scale_color_brewer(palette = "Set1", name = "Group") +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj_2
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present\n(paroxytone)", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj + labs(fill = "Condition")
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj + labs(color = "Condition")
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj + labs(color = "Condition")
model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj + labs(color = "Condition")
# Within group differences
stress_p2 <- model_preds$fits_all %>%
mutate(condition = if_else(condition_sum == 1, "Present", "Preterit"),
condition = fct_relevel(condition, "Present")) %>%
ggplot(., aes(x = time_zero, y = fit, ymax = ymax, ymin = ymin,
fill = condition, color = condition)) +
facet_wrap(group ~ .) +
geom_hline(yintercept = 0, lty = 3, size = 0.4) +
geom_vline(xintercept = 4, lty = 3, size = 0.4) +
stat_summary(fun.y = "mean", geom = "line", size = 1) +
geom_ribbon(alpha = 0.2, color = "grey", show.legend = F) +
# stat_summary(fun.data = mean_cl_boot, geom = 'ribbon',fun.args=list(conf.int=0.95),
#              alpha = 0.5) +
geom_point(aes(color = condition), size = 1.3, show.legend = F) +
geom_point(aes(color = condition), size = 0.85, show.legend = F) +
scale_x_continuous(breaks = c(-4, 0, 4, 8, 12),
labels = c("-200", "0", "200", "400", "600")) +
labs(x = "Time (ms) relative to target syllable offset",
y = "Empirical logit of looks to target") +
theme_big + legend_adj + labs(color = "Condition")
ggsave(paste0(figs_path, "/stress_p2.png"), stress_p2, width = 150,
height = 120, units = "mm", dpi = 600)
# Set path for saving figs
figs_path <- here("figs", "stress", "gca")
ggsave(paste0(figs_path, "/stress_p2.png"), stress_p2, width = 150,
height = 120, units = "mm", dpi = 600)
knitr::include_graphics(
here("figs", "stress", "gca", "stress_p2.png")
)
full_mods_int$gca_full_mod_int_2 %>%
tidy_lme4() %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p)
# Get full mod and make it pretty for the table
pretty_fixed_effects <- full_mods_int$gca_full_mod_int_2 %>%
tidy_lme4() %>%
mutate(p = format_pval(p),
Parameter = fix_param_names(Parameter)) %>%
mutate_each(funs(format_fixef_num), Estimate:t) %>%
rename(`_t_` = t, `_p_` = p)
# Include gammas (Gij) after each parameter name
subs <- c(paste0(0:3, 0), paste0(0:3, 1),
paste0(0:3, 2), paste0(0:3, 3),
paste0(0:3, 4), paste0(0:3, 5),
paste0(0:3, 6))
var_labels <- parenthesize(paste0(emphasize("&gamma;"), "~", subs, "~"))
pretty_fixed_effects$Parameter %<>% paste(., var_labels)
pretty_fixed_effects %>%
knitr::kable(format = "pandoc", align = str_tokenize("lrrrr"))
ranef_table <- full_mods_int$gca_full_mod_int_2 %>%
tidy_ranef_summary %>%
# Format the numbers
mutate_each(funs(format_fixef_num), vcov, sdcor) %>%
mutate_each(funs(format_cor), -var1, -grp, -vcov, -sdcor) %>%
sort_ranef_grps %>%
# Format variable names and group names
mutate(var1 = fix_param_names(var1) %>% blank_nas,
grp =  blank_same_as_last(grp) %>% fix_param_names) %>%
rename(Group = grp, Parameter = var1, Variance = vcov, SD = sdcor)
# Correlation columns need names with characters so that pandoc can align them
names(ranef_table)[5:10] <-
c("Correlations", "&nbsp;", " &nbsp;", "  &nbsp;", "  &nbsp;", "  &nbsp;")
# Correlation columns need names with characters so that pandoc can align them
names(ranef_table)[5:9] <-
c("Correlations", "&nbsp;", " &nbsp;", "  &nbsp;", "  &nbsp;", "  &nbsp;")
# make table for printing
pairwise_comp <- gca_full_mod_refactor %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "aes") == TRUE)
source(here::here("scripts", "00_load_libs.R"))
# Load data
source(here::here("scripts", "02_load_data.R"))
# Get path to saved models
gca_mods_path  <- here("mods", "stress", "gca")
stress_gc_subset <- stress50 %>%
filter(., time_zero >= -4 & time_zero <= 12) %>%
mutate(., group = fct_relevel(group, "mon", "aes", "ams", "ies", "ims"),
condition_sum = if_else(cond == "1", 1, -1)) %>%       # 1 = present, 2 = past
poly_add_columns(., time_zero, degree = 3, prefix = "ot")
gca_mod_mon_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa', optCtrl = list(maxfun = 3e5)),
REML = F,
data = filter(stress_gc_subset, group == "mon")) # singular
# add condition (paroxytone, oxytone) effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_mon_cond_0 <- update(gca_mod_mon_base,   . ~ . + condition_sum) # singular
gca_mod_mon_cond_1 <- update(gca_mod_mon_cond_0,   . ~ . + ot1:condition_sum) # singular
gca_mod_mon_cond_2 <- update(gca_mod_mon_cond_1,   . ~ . + ot2:condition_sum) # singular
gca_mod_mon_cond_3 <- update(gca_mod_mon_cond_2,   . ~ . + ot3:condition_sum) # singular
mon_cond_anova <-
anova(gca_mod_mon_base, gca_mod_mon_cond_0, gca_mod_mon_cond_1,
gca_mod_mon_cond_2, gca_mod_mon_cond_3)
mon_cond_anova
gca_mod_aes_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "aes")) # singular
# add coda effect to intercept, linear slope, quadratic, and cubic time terms
gca_mod_aes_cond_0 <- update(gca_mod_aes_base,   . ~ . + condition_sum) # singular
gca_mod_aes_cond_1 <- update(gca_mod_aes_cond_0,   . ~ . + ot1:condition_sum) # singular
gca_mod_aes_cond_2 <- update(gca_mod_aes_cond_1,   . ~ . + ot2:condition_sum) # singular
gca_mod_aes_cond_3 <- update(gca_mod_aes_cond_2,   . ~ . + ot3:condition_sum) # singular
aes_cond_anova <-
anova(gca_mod_aes_base, gca_mod_aes_cond_0, gca_mod_aes_cond_1,
gca_mod_aes_cond_2, gca_mod_aes_cond_3)
aes_cond_anova
gca_mod_ies_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ies")) # singular
# add cond effect to iesercept, linear slope, quadratic, and cubic time terms
gca_mod_ies_cond_0 <- update(gca_mod_ies_base,   . ~ . + condition_sum) # singular
gca_mod_ies_cond_1 <- update(gca_mod_ies_cond_0,   . ~ . + ot1:condition_sum) # singular
gca_mod_ies_cond_2 <- update(gca_mod_ies_cond_1,   . ~ . + ot2:condition_sum) # singular
gca_mod_ies_cond_3 <- update(gca_mod_ies_cond_2,   . ~ . + ot3:condition_sum) # singular
ies_cond_anova <-
anova(gca_mod_ies_base, gca_mod_ies_cond_0, gca_mod_ies_cond_1,
gca_mod_ies_cond_2, gca_mod_ies_cond_3)
ies_cond_anova
gca_mod_ams_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ams")) # singular
# add cond effect to amsercept, linear slope, quadratic, and cubic time terms
gca_mod_ams_cond_0 <- update(gca_mod_ams_base,   . ~ . + condition_sum) # singular
gca_mod_ams_cond_1 <- update(gca_mod_ams_cond_0,   . ~ . + ot1:condition_sum) # singular
gca_mod_ams_cond_2 <- update(gca_mod_ams_cond_1,   . ~ . + ot2:condition_sum) # singular
gca_mod_ams_cond_3 <- update(gca_mod_ams_cond_2,   . ~ . + ot3:condition_sum) # singular
ams_cond_anova <-
anova(gca_mod_ams_base, gca_mod_ams_cond_0, gca_mod_ams_cond_1,
gca_mod_ams_cond_2, gca_mod_ams_cond_3)
ams_cond_anova
gca_mod_ims_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ims")) # singular
# add cond effect to imsercept, linear slope, quadratic, and cubic time terms
gca_mod_ims_cond_0 <- update(gca_mod_ims_base,   . ~ . + condition_sum) # singular
gca_mod_ims_base <-
lmer(eLog ~ 1 + (ot1 + ot2 + ot3) +
(1 + condition_sum + (ot1 + ot2 + ot3) | participant) +
(1 + ot1 + ot2 + ot3 | target),
control = lmerControl(optimizer = 'bobyqa'), REML = F,
data = filter(stress_gc_subset, group == "ims"))
# add cond effect to imsercept, linear slope, quadratic, and cubic time terms
gca_mod_ims_cond_0 <- update(gca_mod_ims_base,   . ~ . + condition_sum) # singular
gca_mod_ims_cond_1 <- update(gca_mod_ims_cond_0,   . ~ . + ot1:condition_sum) # singular
gca_mod_ims_cond_2 <- update(gca_mod_ims_cond_1,   . ~ . + ot2:condition_sum) # singular
gca_mod_ims_cond_1 <- update(gca_mod_ims_cond_0,   . ~ . + ot1:condition_sum)
gca_mod_ims_cond_3 <- update(gca_mod_ims_cond_2,   . ~ . + ot3:condition_sum) # singular
ims_cond_anova <-
anova(gca_mod_ims_base, gca_mod_ims_cond_0, gca_mod_ims_cond_1,
gca_mod_ims_cond_2, gca_mod_ims_cond_3)
ims_cond_anova
mod_type <- "gca_mod_"
mod_group <- c("mon", "aes", "ies", "ams", "ims")
# Store ind models in list
group_mods <- mget(c(paste0(mod_type, mod_group, mod_spec)))
mod_spec <- c("base", "_cond_0", "_cond_1", "_cond_2", "_cond_3")
# Store ind models in list
group_mods <- mget(c(paste0(mod_type, mod_group, mod_spec)))
mod_spec <- c("_base", "_cond_0", "_cond_1", "_cond_2", "_cond_3")
# Store ind models in list
group_mods <- mget(c(paste0(mod_type, mod_group, mod_spec)))
save(group_mods,
file = here("mods", "stress", "gca",
"group_mods.Rdata"))
group_anovas <- mget(c(paste0(mod_group, "_cond_anova")))
save(group_anovas,
file = here("mods", "stress", "gca",
"group_mod_anovas.Rdata"))
# make table for printing
pairwise_comp <- full_mods_refactor$gca_full_mod_int_2_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "aes") == TRUE)
# Load models as list and store full mod to global env
load(paste0(gca_mods_path, "/full_mods_refactor.Rdata"))
# make table for printing
pairwise_comp <- full_mods_refactor$gca_full_mod_int_2_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "aes") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp$subscript <- c(paste0(0:3, 8), paste0(0:1, 9))
pairwise_comp <- tibble::column_to_rownames(pairwise_comp, 'subscript')
pairwise_comp$subscript <- c(paste0(0:3, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise <- function(row_name) report_fixef_row(pairwise_comp, row_name)
report_pairwise()
# make table for printing
pairwise_comp <- full_mods_refactor$gca_full_mod_int_2_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ams") == TRUE)
# Add subscript column, convert to rownames, and then add it again
pairwise_comp$subscript <- c(paste0(0:3, 8), paste0(0:1, 9))
full_mods_refactor$gca_full_mod_int_2_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "ams") == TRUE)
pairwise_comp
# make table for printing
pairwise_comp <- full_mods_refactor$gca_full_mod_int_2_ams %>%
tidy_lme4 %>%
rename(B = Estimate) %>%
filter(str_detect(Parameter, "mon") == TRUE)
pairwise_comp
# Add subscript column, convert to rownames, and then add it again
pairwise_comp$subscript <- c(paste0(0:3, 8), paste0(0:1, 9))
pairwise_comp <- tibble::column_to_rownames(pairwise_comp, 'subscript')
pairwise_comp$subscript <- c(paste0(0:3, 8), paste0(0:1, 9))
# Shortcut for inline reporting from the above table
report_pairwise <- function(row_name) report_fixef_row(pairwise_comp, row_name)
report_pairwise()
ranef_table <- full_mods_int$gca_full_mod_int_2 %>%
tidy_ranef_summary %>%
# Format the numbers
mutate_each(funs(format_fixef_num), vcov, sdcor) %>%
mutate_each(funs(format_cor), -var1, -grp, -vcov, -sdcor) %>%
sort_ranef_grps %>%
# Format variable names and group names
mutate(var1 = fix_param_names(var1) %>% blank_nas,
grp =  blank_same_as_last(grp) %>% fix_param_names) %>%
rename(Group = grp, Parameter = var1, Variance = vcov, SD = sdcor)
# Correlation columns need names with characters so that pandoc can align them
names(ranef_table)[5:9] <-
c("Correlations", "&nbsp;", " &nbsp;", "  &nbsp;", "  &nbsp;", "  &nbsp;")
ranef_table
ranefLevels()
ranef_table
ranef_table
# Correlation columns need names with characters so that pandoc can align them
names(ranef_table)[5:9] <-
c("Correlations", "&nbsp;", " &nbsp;", "  &nbsp;", "  &nbsp;")
ranef_table %>%
knitr::kable(format = "pandoc", align = str_tokenize("llrrrrrr"))
